<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>OpenAlex Topics Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
            /* Hide scrollbars, we use pan/zoom */
            background-color: #f4f4f9;
        }

        #tree-container {
            width: 100vw;
            height: 100vh;
        }

        .node circle {
            fill: #fff;
            stroke: #4A90E2;
            stroke-width: 2px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .node circle:hover {
            fill: #4A90E2;
            stroke: #fff;
        }

        .node text {
            font: 12px sans-serif;
            cursor: pointer;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
            opacity: 0.6;
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: white;
            border: 1px solid #aaa;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>

    <div id="tree-container"></div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // --- CONFIGURATION ---
        // Point this to your JSON file
        const DATA_URL = "openalex_tree.json";

        // Set dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        const dx = 20; // Vertical spacing between nodes
        const dy = 250; // Horizontal spacing (depth)

        // --- SETUP SVG ---
        const svg = d3.select("#tree-container").append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom().on("zoom", (event) => {
                g.attr("transform", event.transform);
            }))
            .append("g")
            .attr("transform", `translate(${dy / 3},${height / 2})`); // Center initial view

        const g = svg.append("g");
        const tooltip = d3.select("#tooltip");

        // --- LOAD DATA ---
        d3.json(DATA_URL).then(data => {

            const root = d3.hierarchy(data);

            // Collapse all nodes deeper than Level 1 (Domains) initially
            // Level 0 = Root, Level 1 = Domains, Level 2 = Fields, etc.
            root.descendants().forEach(d => {
                if (d.depth > 1) d._children = d.children; // Store children in hidden var
                if (d.depth > 1) d.children = null; // Nullify active children
            });

            root.x0 = height / 2;
            root.y0 = 0;

            // Draw the initial tree
            update(root);

            function update(source) {
                // Compute the new tree layout
                const tree = d3.tree().nodeSize([dx, dy]);
                const treeData = tree(root);

                // Compute the new tree layout
                const nodes = treeData.descendants();
                const links = treeData.links();

                // --- NODES ---
                const node = g.selectAll('g.node')
                    .data(nodes, d => d.id || (d.id = Math.random())); // generic ID if missing

                // Enter new nodes at the parent's previous position
                const nodeEnter = node.enter().append('g')
                    .attr('class', 'node')
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on('click', (event, d) => {
                        // Toggle children on click
                        if (d.children) {
                            d._children = d.children;
                            d.children = null;
                        } else {
                            d.children = d._children;
                            d._children = null;
                        }
                        update(d);
                    })
                    .on("mouseover", function (event, d) {
                        // Optional: Show Works Count in tooltip
                        if (d.data.value) {
                            tooltip.transition().duration(200).style("opacity", .9);
                            tooltip.html(`Works: ${d.data.value.toLocaleString()}`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        }
                    })
                    .on("mouseout", function (d) {
                        tooltip.transition().duration(500).style("opacity", 0);
                    });

                // Add Circle
                nodeEnter.append('circle')
                    .attr('r', 5)
                    .style("fill", d => d._children ? "#4A90E2" : "#fff"); // Blue if expandable

                // Add Text
                nodeEnter.append('text')
                    .attr("dy", ".35em")
                    .attr("x", d => d.children || d._children ? -13 : 13)
                    .attr("text-anchor", d => d.children || d._children ? "end" : "start")
                    .text(d => d.data.name)
                    .clone(true).lower() // Add white stroke for readability
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 3)
                    .attr("stroke", "white");

                // UPDATE nodes
                const nodeUpdate = node.merge(nodeEnter).transition().duration(250)
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                nodeUpdate.select('circle')
                    .attr('r', 5)
                    .style("fill", d => d._children ? "#4A90E2" : "#fff")
                    .attr('cursor', 'pointer');

                // EXIT nodes
                const nodeExit = node.exit().transition().duration(250)
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();

                nodeExit.select('circle').attr('r', 1e-6);
                nodeExit.select('text').style('fill-opacity', 1e-6);

                // --- LINKS ---
                const link = g.selectAll('path.link')
                    .data(links, d => d.target.id);

                // Enter any new links at the parent's previous position
                const linkEnter = link.enter().insert('path', "g")
                    .attr("class", "link")
                    .attr('d', d => {
                        const o = { x: source.x0, y: source.y0 };
                        return diagonal(o, o);
                    });

                // UPDATE links
                const linkUpdate = link.merge(linkEnter).transition().duration(250)
                    .attr('d', d => diagonal(d.source, d.target));

                // EXIT links
                link.exit().transition().duration(250)
                    .attr('d', d => {
                        const o = { x: source.x, y: source.y };
                        return diagonal(o, o);
                    })
                    .remove();

                // Store the old positions for transition
                nodes.forEach(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                // Curved path generator
                function diagonal(s, d) {
                    return `M ${s.y} ${s.x}
                        C ${(s.y + d.y) / 2} ${s.x},
                          ${(s.y + d.y) / 2} ${d.x},
                          ${d.y} ${d.x}`;
                }
            }
        }).catch(err => {
            console.error("Error loading JSON:", err);
            alert("Could not load 'openalex_tree.json'. Make sure you are running a local server (python -m http.server) and the file is in the same folder.");
        });
    </script>

</body>

</html>